<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>2048 ‚Äî Mobile Perf</title>
<style>
  :root {
  --gap: 12px;
  --radius: 12px;
  --board-bg: #bbada0;
  --cell-bg: rgba(238, 228, 218, 0.35);
  --page-bg: #0f1217;
  --anim: 90ms;
  --ease: cubic-bezier(.2,.8,.2,1);
  --y-fix: 2px; /* –æ–ø—É—Å–∫–∞–µ–º –ø–ª–∏—Ç–∫–∏ —á—É—Ç—å –Ω–∏–∂–µ; –ø–æ–ø—Ä–æ–±—É–π 1‚Äì3px –ø–æ–¥ —Å–≤–æ–π —ç–∫—Ä–∞–Ω */
}
  @media (prefers-reduced-motion: reduce) {
    :root { --anim: 0ms; }
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    color: #e8e8e8;
    background: var(--page-bg);
    font: 600 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    display: grid;
    place-items: center;
    padding: 16px;
  }
  .wrap { width: min(96vw, 520px); }
  .topbar {
    display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap;
    margin-bottom: 12px;
  }
  .brand { font-size: 20px; font-weight: 900; letter-spacing: .02em; }
  .scores { display: flex; gap: 8px; }
  .badge {
    background: rgba(255,255,255,.06);
    border: 1px solid rgba(255,255,255,.12);
    padding: 6px 10px;
    border-radius: 10px;
    min-width: 90px;
    text-align: center;
    font-weight: 800;
  }
  .badge b { display: block; color: #ffd54f; font-size: 18px; margin-top: 2px; }
  .controls {
    display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px;
  }
  button, select {
    background: rgba(255,255,255,.08);
    color: #fff; border: 1px solid rgba(255,255,255,.12);
    border-radius: 10px; padding: 8px 12px;
    font-weight: 800; cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }
  button:hover { background: rgba(255,255,255,.12); }
  button:active { transform: translateY(1px); }
  .hint { opacity: .8; margin: 6px 0 10px; }

  .board {
    position: relative;
    width: 100%;
    aspect-ratio: 1/1;
    background: var(--board-bg);
    border-radius: calc(var(--radius) + 4px);
    padding: var(--gap);
    user-select: none;
    touch-action: none;
    contain: content; /* –∏–∑–æ–ª—è—Ü–∏—è –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–æ–∫ */
  }
  .grid, .tiles { position: absolute; inset: var(--gap); }
  .grid {
    display: grid;
    grid-template-columns: repeat(var(--size), 1fr);
    grid-auto-rows: 1fr;
    gap: var(--gap);
    height: 100%;
  }
  .cell {
    background: var(--cell-bg);
    border-radius: var(--radius);
  }
  .tiles {
    pointer-events: none;
    will-change: transform;
  }

  .tile {
    position: absolute;
    border-radius: var(--radius);
    display: grid; place-items: center;
    font-weight: 900;
    /* —Ç–æ–ª—å–∫–æ GPU-–∫–æ–º–ø–æ–∑–∏—Ç–∏–Ω–≥ */
    transform: translate3d(var(--tx,0), calc(var(--ty,0) + var(--y-fix,0px)), 0) scale(var(--s,1));
    transition: transform var(--anim) var(--ease);
    will-change: transform;
    backface-visibility: hidden;
    contain: layout paint style;
  }
  .tile.bump {
    animation: bump var(--anim) ease-out;
  }
@keyframes bump {
  0%   { transform: translate3d(var(--tx), calc(var(--ty) + var(--y-fix,0px)), 0) scale(1); }
  50%  { transform: translate3d(var(--tx), calc(var(--ty) + var(--y-fix,0px)), 0) scale(1.11); }
  100% { transform: translate3d(var(--tx), calc(var(--ty) + var(--y-fix,0px)), 0) scale(1); }
}

  .overlay {
    position: absolute; inset: 0;
    display: none; place-items: center;
    background: rgba(0,0,0,.35);
    border-radius: calc(var(--radius) + 4px);
  }
  .overlay.show { display: grid; }
  .panel {
    background: rgba(0,0,0,.55);
    border: 1px solid rgba(255,255,255,.15);
    padding: 14px 16px;
    border-radius: 12px;
    text-align: center;
    font-weight: 800;
    min-width: 60%;
  }
  .panel .title { font-size: 20px; margin-bottom: 6px; }
  .panel .row { margin-top: 8px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">2048</div>
      <div class="scores">
        <div class="badge">Score<b id="score">0</b></div>
        <div class="badge">Best<b id="best">0</b></div>
      </div>
    </div>

    <div class="controls">
      <button id="newGame">New Game</button>
      <button id="undo">Undo</button>
      <label>Size:
        <select id="sizeSel">
          <option>3</option>
          <option selected>4</option>
          <option>5</option>
          <option>6</option>
        </select>
      </label>
    </div>

    <div class="hint">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üê ‚Üë ‚Üí ‚Üì –∏–ª–∏ WASD. –ù–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ ‚Äî —Å–≤–∞–π–ø—ã. –ü–æ–±–µ–¥–∞ –Ω–∞ 2048 (–º–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å).</div>

    <div class="board" id="board" style="--size:4">
      <div class="grid" id="grid"></div>
      <div class="tiles" id="tiles"></div>

      <div class="overlay" id="winOv">
        <div class="panel">
          <div class="title">üéâ 2048!</div>
          <div>–•–æ—á–µ—à—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–≥—Ä—É?</div>
          <div class="row">
            <button id="continue">Continue</button>
            <button id="newFromWin">New Game</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="loseOv">
        <div class="panel">
          <div class="title">üí• –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</div>
          <div class="row">
            <button id="restart">Try Again</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // DOM
  const boardEl = document.getElementById('board');
  const gridEl  = document.getElementById('grid');
  const tilesEl = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const sizeSel = document.getElementById('sizeSel');
  const btnNew  = document.getElementById('newGame');
  const btnUndo = document.getElementById('undo');
  const winOv   = document.getElementById('winOv');
  const loseOv  = document.getElementById('loseOv');
  const btnContinue = document.getElementById('continue');
  const btnNewFromWin = document.getElementById('newFromWin');
  const btnRestart = document.getElementById('restart');

  // State
  let size = parseInt(localStorage.getItem('2048-size') || '4', 10);
  sizeSel.value = String(size);
  boardEl.style.setProperty('--size', size);

  let tiles = []; // {id,x,y,value, merged, scale}
  let idSeq = 1;
  let score = 0;
  let best = parseInt(localStorage.getItem('2048-best') || '0', 10);
  bestEl.textContent = best;

  let keepPlaying = false;
  let won = false;
  let over = false;
  let moveLock = false; // –±–ª–æ–∫ –≤—Ö–æ–¥–∞ –Ω–∞ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏

  let undoState = null;

  // Metrics
  const GAP = 12;
  let cell = 0;
  function computeCell() {
    const inner = tilesEl.getBoundingClientRect().width;
    if (inner > 0) cell = (inner - GAP * (size - 1)) / size;
    else cell = (boardEl.clientWidth - GAP*2 - GAP*(size-1)) / size;
    if (!Number.isFinite(cell) || cell <= 0) cell = 64; // —Ñ–æ–ª–±–µ–∫
  }
  window.addEventListener('resize', () => { computeCell(); layoutTiles(); });

  // Utils
  const inBounds = (x,y) => x>=0 && x<size && y>=0 && y<size;
  const VECTORS = { left:{x:-1,y:0}, right:{x:1,y:0}, up:{x:0,y:-1}, down:{x:0,y:1} };
  const valueStyle = (v) => {
    const bg = {
      2:'#eee4da', 4:'#ede0c8', 8:'#f2b179', 16:'#f59563', 32:'#f67c5f', 64:'#f65e3b',
      128:'#edcf72', 256:'#edcc61', 512:'#edc850', 1024:'#edc53f', 2048:'#edc22e'
    }[v] || '#3c3a32';
    const color = v <= 4 ? '#776e65' : '#f9f6f2';
    return { bg, color };
  };
  const fontSizeK = (v) => v < 100 ? .42 : v < 1000 ? .38 : v < 10000 ? .33 : .30;

  // Grid helpers
  function setupGridCells() {
    gridEl.innerHTML = '';
    for (let i=0;i<size*size;i++) {
      const cellEl = document.createElement('div');
      cellEl.className = 'cell';
      gridEl.appendChild(cellEl);
    }
  }
  function getGrid() {
    const g = Array.from({length:size}, () => Array(size).fill(null));
    for (const t of tiles) g[t.x][t.y] = t;
    return g;
  }
  function emptyCells() {
    const g = getGrid(); const arr = [];
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) if (!g[x][y]) arr.push({x,y});
    return arr;
  }

  // Tile DOM
  function createTileEl(t) {
    const el = document.createElement('div');
    el.className = 'tile';
    el.dataset.id = t.id;
    tilesEl.appendChild(el);
    styleTile(t, true);
  }
  function qTileEl(t) { return tilesEl.querySelector(`.tile[data-id="${t.id}"]`); }
  function styleTile(t, spawn=false, bump=false) {
    const el = qTileEl(t); if (!el) return;
    el.style.width = el.style.height = cell + 'px';
    const tx = t.x * (cell + GAP);
    const ty = t.y * (cell + GAP);
    el.style.setProperty('--tx', tx+'px');
    el.style.setProperty('--ty', ty+'px');
    el.style.setProperty('--s', spawn ? (t.scale ?? 1) : 1);

    if (t._needsText) {
      el.textContent = t.value;
      const { bg, color } = valueStyle(t.value);
      el.style.background = bg;
      el.style.color = color;
      el.style.fontSize = (fontSizeK(t.value) * cell) + 'px';
      t._needsText = false;
    }
    if (bump) {
      // –ë–µ–∑ reflow: —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —á–µ—Ä–µ–∑ inline-style
      el.style.animation = 'none';
      requestAnimationFrame(() => {
        el.style.animation = '';
        el.classList.add('bump');
        // —É–±—Ä–∞—Ç—å –∫–ª–∞—Å—Å –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, —á—Ç–æ–±—ã –Ω–µ –∫–æ–ø–∏–ª–æ—Å—å
        const clear = () => { el.classList.remove('bump'); el.removeEventListener('animationend', clear); };
        el.addEventListener('animationend', clear);
      });
    }
  }
  function layoutTiles() {
    for (const t of tiles) styleTile(t, false, false);
  }
  function removeTileEl(t) {
    const el = qTileEl(t);
    if (el && el.parentNode) el.parentNode.removeChild(el);
  }

  // Score
  function setScore(val) {
    score = val; scoreEl.textContent = score;
    if (score > best) {
      best = score; bestEl.textContent = best;
      try { localStorage.setItem('2048-best', String(best)); } catch {}
    }
  }
  function addScore(delta) { setScore(score + delta); }

  // Game
  function reset() {
    tiles = []; idSeq = 1; over = false; won = false; keepPlaying = false; moveLock = false;
    setScore(0);
    tilesEl.innerHTML = '';
    winOv.classList.remove('show'); loseOv.classList.remove('show');
    setupGridCells();
    computeCell();

    spawnRandom(true);
    spawnRandom(true);
    saveUndo();
  }

  function spawnRandom(spawn=false) {
    const empties = emptyCells();
    if (!empties.length) return false;
    const {x,y} = empties[Math.floor(Math.random()*empties.length)];
    const val = Math.random() < 0.9 ? 2 : 4;
    const t = { id: idSeq++, x, y, value: val, scale: spawn ? 0.1 : 1, _needsText: true };
    tiles.push(t);
    createTileEl(t);
    if (spawn) requestAnimationFrame(() => {
      t.scale = 1;
      styleTile(t, true, false);
    });
    return true;
  }

  function buildTraversals(vec) {
    const xs = [...Array(size).keys()];
    const ys = [...Array(size).keys()];
    if (vec.x === 1) xs.reverse();
    if (vec.y === 1) ys.reverse();
    return { xs, ys };
  }
  function findFarthest(cell, vec, grid) {
    let prev, x = cell.x, y = cell.y;
    do { prev = {x,y}; x += vec.x; y += vec.y; } while (inBounds(x,y) && !grid[x][y]);
    return { farthest: prev, next: {x, y} };
  }
  function canMoveAny() {
    const g = getGrid();
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) if (!g[x][y]) return true;
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) {
      const t = g[x][y]; if (!t) continue;
      for (const v of Object.values(VECTORS)) {
        const nx = x+v.x, ny = y+v.y; if (!inBounds(nx,ny)) continue;
        const n = g[nx][ny]; if (n && n.value === t.value) return true;
      }
    }
    return false;
  }

  const ANIM_MS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--anim')) || 0;

  function move(dir) {
    if (over || moveLock) return;
    moveLock = true;

    const vec = VECTORS[dir];
    const { xs, ys } = buildTraversals(vec);
    const grid = getGrid();
    let moved = false;
    let gained = 0;
    const toRemove = new Set();
    const toBump = [];

    for (const t of tiles) t.merged = false;

    for (const y of ys) for (const x of xs) {
      const t = grid[x][y];
      if (!t) continue;

      const { farthest, next } = findFarthest({x,y}, vec, grid);
      const n = inBounds(next.x,next.y) ? grid[next.x][next.y] : null;

      if (n && n.value === t.value && !n.merged) {
        // merge t into n-position (we store result in t)
        grid[t.x][t.y] = null;
        t.x = next.x; t.y = next.y;
        t.value *= 2; t.merged = true; t._needsText = true;
        grid[next.x][next.y] = t;

        toRemove.add(n);
        moved = true;
        gained += t.value;
        toBump.push(t);
      } else {
        if (farthest.x !== t.x || farthest.y !== t.y) {
          grid[t.x][t.y] = null;
          t.x = farthest.x; t.y = farthest.y;
          grid[t.x][t.y] = t;
          moved = true;
        }
      }
    }

    if (!moved) { moveLock = false; return; }

    // Remove merged counterparts from model + DOM
    if (toRemove.size) {
      tiles = tiles.filter(t => !toRemove.has(t));
      for (const r of toRemove) removeTileEl(r);
    }

    // Batch style updates in rAF
    requestAnimationFrame(() => {
      for (const t of tiles) styleTile(t, false, false);
      for (const t of toBump) styleTile(t, false, true);
    });

    // After anim ends: spawn new and checks
    setTimeout(() => {
      if (gained) addScore(gained);
      if (tiles.some(t => t.value === 2048) && !keepPlaying) {
        won = true; winOv.classList.add('show');
      } else {
        spawnRandom(true);
        saveUndo();
        if (!canMoveAny()) { over = true; loseOv.classList.add('show'); }
      }
      moveLock = false;
    }, ANIM_MS);
  }

  // Undo (single step)
  function saveUndo() {
    undoState = {
      tiles: tiles.map(t => ({...t})),
      score, won, keepPlaying, over
    };
  }
  function undo() {
    if (!undoState || moveLock) return;
    tiles = undoState.tiles.map(t => ({...t}));
    score = undoState.score; scoreEl.textContent = score;
    won = undoState.won; keepPlaying = undoState.keepPlaying; over = undoState.over;
    tilesEl.innerHTML = '';
    for (const t of tiles) { t._needsText = true; createTileEl(t); }
    layoutTiles();
    winOv.classList.toggle('show', won && !keepPlaying);
    loseOv.classList.toggle('show', over);
  }

  // Input
  document.addEventListener('keydown', (e) => {
    const c = e.code;
    if (winOv.classList.contains('show') || loseOv.classList.contains('show')) {
      if (c === 'Enter' || c === 'Space') {
        if (winOv.classList.contains('show')) { keepPlaying = true; winOv.classList.remove('show'); }
        else restart();
      }
      return;
    }
    if (c === 'ArrowLeft' || c === 'KeyA') { e.preventDefault(); move('left'); }
    if (c === 'ArrowRight'|| c === 'KeyD') { e.preventDefault(); move('right'); }
    if (c === 'ArrowUp'   || c === 'KeyW') { e.preventDefault(); move('up'); }
    if (c === 'ArrowDown' || c === 'KeyS') { e.preventDefault(); move('down'); }
    if (c === 'KeyU') { e.preventDefault(); undo(); }
    if (c === 'KeyN' || c === 'KeyR') { e.preventDefault(); restart(); }
  }, { passive: false });

  // Touch swipes (fast + passive)
  let sx=0, sy=0, st=0;
  boardEl.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    sx=t.clientX; sy=t.clientY; st=performance.now();
  }, {passive:true});
  boardEl.addEventListener('touchend', (e) => {
    const t = e.changedTouches[0];
    const dx=t.clientX-sx, dy=t.clientY-sy, dt=performance.now()-st;
    const thr=24; if (dt>800) return;
    if (Math.abs(dx)<thr && Math.abs(dy)<thr) return;
    if (Math.abs(dx)>Math.abs(dy)) move(dx>0?'right':'left');
    else move(dy>0?'down':'up');
  }, {passive:true});

  // Buttons
  function restart() {
    winOv.classList.remove('show'); loseOv.classList.remove('show');
    keepPlaying = false; won = false; over = false;
    reset();
  }
  btnNew.addEventListener('click', restart);
  btnUndo.addEventListener('click', undo);
  sizeSel.addEventListener('change', () => {
    size = parseInt(sizeSel.value, 10);
    try { localStorage.setItem('2048-size', String(size)); } catch {}
    boardEl.style.setProperty('--size', size);
    restart();
  });
  btnContinue.addEventListener('click', () => { keepPlaying = true; winOv.classList.remove('show'); });
  btnNewFromWin.addEventListener('click', restart);
  btnRestart.addEventListener('click', restart);

  // Boot
  function boot() {
    setupGridCells();
    computeCell();
    reset();
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>
</body>
</html>
