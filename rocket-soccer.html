<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Match-3 (в духе Candy Crush)</title>
  <style>
    :root{
      --cell: 64px;
      --gap: 6px;
      --bg: #111418;
      --panel: #1b2128;
      --text: #eaf1f8;
      --accent: #66d1ff;
    }
    * { box-sizing: border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(1200px 600px at 80% -20%, #1b1f2a 0, transparent 60%),
        radial-gradient(1000px 700px at -10% 100%, #0b0f14 0, transparent 60%),
        var(--bg);
      color:var(--text);
      font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap{
      width:min(98vw, 760px);
      display:grid;
      grid-template-columns: 1fr auto;
      gap:16px;
      align-items:start;
      padding:18px;
    }
    h1{
      grid-column:1/-1;
      margin:0;
      font-weight:800;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:20px;
    }
    h1 .dot{ width:10px; height:10px; border-radius:50%; background: var(--accent); display:inline-block; box-shadow:0 0 12px #66d1ff80; }
    .hud{
      display:flex;
      gap:10px;
      align-items:center;
      background:var(--panel);
      padding:10px 12px;
      border-radius:12px;
      border:1px solid #ffffff10;
      box-shadow: 0 6px 20px #00000050, inset 0 1px 0 #ffffff10;
    }
    .hud .card{
      background:#0f141a;
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #ffffff0f;
      min-width:120px;
      text-align:center;
    }
    .hud .big{ font-size:20px; font-weight:800; }
    .hud .label{ font-size:12px; color:#b8c2cc; letter-spacing:.2px; }
    .btn{
      appearance:none; border:0; background:linear-gradient(180deg, #2e7df7, #1857df);
      color:#fff; font-weight:700; padding:10px 14px; border-radius:10px;
      box-shadow:0 6px 16px #1653d060, inset 0 1px 0 #ffffff66; cursor:pointer;
      transition:.15s transform ease, .15s filter ease;
    }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .hint{
      color:#b8c2cc; margin:0; align-self:center;
    }

    .board{
      grid-column:1/-1;
      background:#0b0e12;
      padding:var(--gap);
      border-radius:14px;
      border:1px solid #ffffff10;
      box-shadow:
        0 10px 30px #00000070,
        inset 0 2px 0 #ffffff08,
        inset 0 -2px 0 #00000070;
      display:grid;
      grid-template-columns: repeat(8, var(--cell));
      gap: var(--gap);
      touch-action: manipulation;
      position:relative;
    }
    .board.shake{ animation:shake .18s ease; }
    @keyframes shake {
      0%{ transform: translateX(0) }
      25%{ transform: translateX(-4px) }
      50%{ transform: translateX(4px) }
      75%{ transform: translateX(-2px) }
      100%{ transform: translateX(0) }
    }

    .cell{
      width:var(--cell);
      height:var(--cell);
      border-radius:14px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid #00000040;
      box-shadow: inset 0 -8px 0 #00000030, inset 0 1px 0 #ffffff20;
      cursor:pointer;
      transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
      position:relative;
      overflow:hidden;
    }
    .cell:hover{ transform: scale(1.06); }
    .cell.selected{
      outline:3px solid #ffffffcc;
      filter: brightness(1.1) saturate(1.15);
      z-index:2;
    }
    .cell.empty{ visibility:hidden; }

    .candy{
      width:84%;
      height:84%;
      border-radius:50%;
      box-shadow:
        inset 0 -10px 16px #00000035,
        inset 0 -2px 2px #00000050,
        0 4px 10px #00000050;
      position:relative;
      transition: transform .12s ease, opacity .12s ease, filter .12s ease;
    }
    .candy::after{
      content:"";
      position:absolute;
      left:8%; top:10%;
      width:50%; height:40%;
      border-radius:50%;
      background: linear-gradient(180deg, #ffffffcc, transparent 70%);
      filter: blur(2px);
      opacity:.8;
      transform: rotate(-20deg);
      pointer-events:none;
    }

    /* 6 типов конфет — цвета + легкие полоски */
    .type-0 .candy{
      background:
        repeating-linear-gradient(45deg, #ff9c9c 0 10px, #ff7f7f 10px 20px),
        radial-gradient(circle at 30% 30%, #ffb9b9, #ff4141);
    }
    .type-1 .candy{
      background:
        repeating-linear-gradient(45deg, #ffd49c 0 10px, #ffbf6b 10px 20px),
        radial-gradient(circle at 30% 30%, #ffdcae, #ff9933);
    }
    .type-2 .candy{
      background:
        repeating-linear-gradient(45deg, #fff19c 0 10px, #ffe36b 10px 20px),
        radial-gradient(circle at 30% 30%, #fff3b0, #ffcf33);
    }
    .type-3 .candy{
      background:
        repeating-linear-gradient(45deg, #a5f5b0 0 10px, #76e592 10px 20px),
        radial-gradient(circle at 30% 30%, #c7fbd0, #23c766);
    }
    .type-4 .candy{
      background:
        repeating-linear-gradient(45deg, #a4c7ff 0 10px, #7dadff 10px 20px),
        radial-gradient(circle at 30% 30%, #c1d6ff, #3f7bff);
    }
    .type-5 .candy{
      background:
        repeating-linear-gradient(45deg, #d9a8ff 0 10px, #c384ff 10px 20px),
        radial-gradient(circle at 30% 30%, #eac8ff, #8f3fff);
    }

    .crush{ animation: crush .24s ease forwards; }
    .new{ animation: popIn .18s ease; }
    @keyframes crush{
      50%{ transform: scale(0.7); filter: brightness(1.3); }
      100%{ transform: scale(0); opacity:0; }
    }
    @keyframes popIn{
      from{ transform: scale(.6); opacity:.6; }
      to{ transform: scale(1); opacity:1; }
    }

    .overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:#00000080; backdrop-filter: blur(2px);
      opacity:0; pointer-events:none; transition:.2s opacity ease;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }
    .modal{
      background:var(--panel); border:1px solid #ffffff1a; border-radius:14px;
      padding:20px; width:min(92vw, 380px); text-align:center;
      box-shadow: 0 20px 40px #00000080, inset 0 1px 0 #ffffff10;
    }
    .modal h2{ margin:0 0 6px 0; }
    .modal p{ margin:4px 0 16px 0; color:#cbd5e1; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>
      <span class="dot"></span>
      Bewords game : match-3
    </h1>

    <div class="hud">
      <div class="card">
        <div class="label">Счет</div>
        <div class="big" id="score">0</div>
      </div>
      <div class="card">
        <div class="label">Ходы</div>
        <div class="big" id="moves">30</div>
      </div>
      <button class="btn" id="restart">Перезапуск</button>
    </div>
    <p class="hint">Кликни по фишке, затем по соседней (вверх/вниз/влево/вправо), чтобы поменять их местами.</p>

    <div class="board" id="board" aria-label="Игровое поле" role="grid"></div>
  </div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <h2>Игра окончена!</h2>
      <p>Ваш счет: <b id="finalScore">0</b></p>
      <button class="btn" id="playAgain">Сыграть еще</button>
    </div>
  </div>

  <script>
    (()=> {
      const ROWS = 8;
      const COLS = 8;
      const TYPES = 6; // количество цветов
      const START_MOVES = 30;

      const $board = document.getElementById('board');
      const $score = document.getElementById('score');
      const $moves = document.getElementById('moves');
      const $restart = document.getElementById('restart');
      const $overlay = document.getElementById('overlay');
      const $finalScore = document.getElementById('finalScore');
      const $playAgain = document.getElementById('playAgain');

      let board = [];
      let score = 0;
      let movesLeft = START_MOVES;
      let selected = null; // {r,c}
      let busy = false;

      // Utils
      const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));
      const inBounds = (r,c)=> r>=0 && r<ROWS && c>=0 && c<COLS;
      const isNeighbor = (a,b)=> a && b && (Math.abs(a.r-b.r)+Math.abs(a.c-b.c)===1);
      const randType = ()=> Math.floor(Math.random()*TYPES);

      // Board generation
      function newBoardRandom(){
        board = Array.from({length:ROWS}, _ => Array.from({length:COLS}, _ => randType()));
      }
      function findMatches(){
        const set = new Set();

        // horizontal
        for(let r=0; r<ROWS; r++){
          let count = 1;
          for(let c=1; c<=COLS; c++){
            const prev = board[r][c-1];
            const curr = c<COLS ? board[r][c] : null;
            if(curr === prev && prev !== -1){
              count++;
            }else{
              if(prev !== -1 && count >= 3){
                for(let k=0; k<count; k++){
                  set.add(`${r},${c-1-k}`);
                }
              }
              count = 1;
            }
          }
        }
        // vertical
        for(let c=0; c<COLS; c++){
          let count = 1;
          for(let r=1; r<=ROWS; r++){
            const prev = board[r-1][c];
            const curr = r<ROWS ? board[r][c] : null;
            if(curr === prev && prev !== -1){
              count++;
            }else{
              if(prev !== -1 && count >= 3){
                for(let k=0; k<count; k++){
                  set.add(`${r-1-k},${c}`);
                }
              }
              count = 1;
            }
          }
        }
        return set;
      }
      function swapInBoard(a, b){
        const t = board[a.r][a.c];
        board[a.r][a.c] = board[b.r][b.c];
        board[b.r][b.c] = t;
      }
      function hasAvailableMoves(){
        // brute force: проверяем свап справа и вниз
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            const here = {r,c};
            const right = {r, c:c+1};
            if(inBounds(right.r,right.c)){
              swapInBoard(here, right);
              const any = findMatches().size>0;
              swapInBoard(here, right);
              if(any) return true;
            }
            const down = {r:r+1, c};
            if(inBounds(down.r,down.c)){
              swapInBoard(here, down);
              const any = findMatches().size>0;
              swapInBoard(here, down);
              if(any) return true;
            }
          }
        }
        return false;
      }
      function ensureStartableBoard(){
        // до тех пор, пока на поле есть автосовпадения или нет ходов — генерируем заново
        let safety = 0;
        do {
          newBoardRandom();
          safety++;
          if(safety>500) break;
        } while(findMatches().size>0 || !hasAvailableMoves());
      }

      function collapseAndFill(){
        // Опускаем фишки вниз и генерим новые сверху
        const newCells = [];
        for(let c=0;c<COLS;c++){
          let write = ROWS - 1;
          for(let r=ROWS-1;r>=0;r--){
            if(board[r][c] !== -1){
              board[write][c] = board[r][c];
              if(write !== r) board[r][c] = -1;
              write--;
            }
          }
          for(let r=write; r>=0; r--){
            board[r][c] = randType();
            newCells.push({r,c});
          }
        }
        return newCells;
      }

      // Rendering
      function renderBoard(){
        $board.innerHTML = "";
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            const wrapper = document.createElement('button');
            wrapper.className = 'cell';
            wrapper.type = 'button';
            wrapper.setAttribute('role','gridcell');
            wrapper.dataset.row = r;
            wrapper.dataset.col = c;
            const val = board[r][c];
            if(val === -1){
              wrapper.classList.add('empty');
            } else {
              wrapper.classList.add(`type-${val}`);
              const candy = document.createElement('div');
              candy.className = 'candy';
              wrapper.appendChild(candy);
            }
            if(selected && selected.r===r && selected.c===c){
              wrapper.classList.add('selected');
            }
            wrapper.addEventListener('click', onCellClick, {passive:true});
            $board.appendChild(wrapper);
          }
        }
        $score.textContent = String(score);
        $moves.textContent = String(movesLeft);
      }
      function addCrushAnimation(matchSet){
        for(const key of matchSet){
          const [r,c] = key.split(',').map(Number);
          const el = queryCell(r,c);
          if(el) el.classList.add('crush');
        }
      }
      function addNewAnimation(cells){
        for(const {r,c} of cells){
          const el = queryCell(r,c);
          if(!el) continue;
          el.classList.add('new');
        }
      }
      function queryCell(r,c){
        return $board.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      }

      // Game flow
      async function resolveCascade(){
        let chain = 0;
        while(true){
          const matches = findMatches();
          if(matches.size === 0) break;

          chain++;
          const points = matches.size * 10 * chain; // небольшой бонус за цепочку
          score += points;
          addCrushAnimation(matches);
          updateHud();

          await sleep(240);
          // очистка
          for(const key of matches){
            const [r,c] = key.split(',').map(Number);
            board[r][c] = -1;
          }
          const newCells = collapseAndFill();
          renderBoard();
          addNewAnimation(newCells);
          await sleep(120);
        }
      }

      function updateHud(){
        $score.textContent = String(score);
        $moves.textContent = String(movesLeft);
      }

      async function trySwap(a,b){
        if(busy) return;
        busy = true;
        swapInBoard(a,b);
        renderBoard();
        await sleep(120);

        const matches = findMatches();
        if(matches.size > 0){
          // успешный ход
          movesLeft = Math.max(0, movesLeft - 1);
          updateHud();
          await resolveCascade();
          // Проверка конца игры и отсутствия ходов
          if(movesLeft <= 0){
            endGame();
          } else if(!hasAvailableMoves()){
            await shuffleBoardAnimated();
          }
        } else {
          // неуспешный — откат и анимация "shake"
          swapInBoard(a,b);
          renderBoard();
          $board.classList.add('shake');
          setTimeout(()=> $board.classList.remove('shake'), 200);
        }
        selected = null;
        renderBoard();
        busy = false;
      }

      async function shuffleBoardAnimated(){
        // безопасное перемешивание: без мгновенных совпадений и с доступными ходами
        let tries = 0;
        do {
          const pool = [];
          for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) pool.push(board[r][c]);
          // Fisher–Yates
          for(let i=pool.length-1;i>0;i--){
            const j = Math.floor(Math.random()*(i+1));
            [pool[i], pool[j]] = [pool[j], pool[i]];
          }
          let idx = 0;
          for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) board[r][c] = pool[idx++];
          tries++;
          if(tries>200){
            ensureStartableBoard();
            break;
          }
        } while(findMatches().size>0 || !hasAvailableMoves());
        renderBoard();
        // легкая подсветка "новизны"
        const all = [];
        for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) all.push({r,c});
        addNewAnimation(all);
        await sleep(160);
      }

      // Events
      function onCellClick(e){
        if(busy) return;
        const el = e.currentTarget;
        const r = +el.dataset.row;
        const c = +el.dataset.col;
        const pos = {r,c};

        if(!selected){
          selected = pos;
          renderBoard();
          return;
        }
        if(selected.r === r && selected.c === c){
          selected = null;
          renderBoard();
          return;
        }
        if(isNeighbor(selected, pos)){
          trySwap(selected, pos);
        } else {
          selected = pos;
          renderBoard();
        }
      }

      function endGame(){
        busy = true;
        $finalScore.textContent = String(score);
        $overlay.classList.add('show');
      }
      function resetGame(){
        score = 0;
        movesLeft = START_MOVES;
        selected = null;
        busy = false;
        ensureStartableBoard();
        renderBoard();
      }

      // Init
      $restart.addEventListener('click', resetGame);
      $playAgain.addEventListener('click', ()=> {
        $overlay.classList.remove('show');
        resetGame();
      });

      // First start
      resetGame();
    })();
  </script>
</body>
</html>
