<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>2048 ‚Äî Mobile Perf (—Ç–æ—á–Ω–æ–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –±–µ–∑ –æ–±—Ä–µ–∑–∞–Ω–∏—è)</title>
<style>
  :root {
    --gap: 12px;
    --radius: 12px;
    --board-bg: #bbada0;              /* –±–µ–∂–µ–≤–∞—è –ø–æ–¥–ª–æ–∂–∫–∞ */
    --cell-bg: rgba(238, 228, 218, .35); /* –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ —Å–µ—Ç–∫–∏ */
    --page-bg: #0f1217;
    --anim: 90ms;
    --ease: cubic-bezier(.2,.8,.2,1);
  }
  @media (prefers-reduced-motion: reduce) { :root { --anim: 0ms; } }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body{
    margin:0; color:#e8e8e8; background:var(--page-bg);
    font:600 14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial;
    display:grid; place-items:center; padding:16px;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    overflow-x:hidden;
  }
  .wrap{ width:min(96vw,520px); }
  .topbar{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:12px; }
  .brand{ font-size:20px; font-weight:900; letter-spacing:.02em; }
  .scores{ display:flex; gap:8px; }
  .badge{
    background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
    padding:6px 10px; border-radius:10px; min-width:90px; text-align:center; font-weight:800;
  }
  .badge b{ display:block; color:#ffd54f; font-size:18px; margin-top:2px; line-height:1; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px; }
  button,select{
    background:rgba(255,255,255,.08); color:#fff; border:1px solid rgba(255,255,255,.12);
    border-radius:10px; padding:8px 12px; font-weight:800; cursor:pointer; -webkit-tap-highlight-color:transparent;
  }
  button:hover{ background:rgba(255,255,255,.12); }
  button:active{ transform:translateY(1px); }
  .hint{ opacity:.8; margin:6px 0 10px; }

  /* –î–æ—Å–∫–∞: –∫–≤–∞–¥—Ä–∞—Ç 1:1; padding –¥–∞—ë—Ç –æ—Ç—Å—Ç—É–ø –¥–æ —Å–µ—Ç–∫–∏. overflow: hidden ‚Äî —á—Ç–æ–±—ã —É–≥–ª—ã –Ω–µ ¬´—Ç–æ—Ä—á–∞–ª–∏¬ª */
  .board{
    position:relative; width:100%; aspect-ratio:1/1;
    background:var(--board-bg); border-radius:calc(var(--radius) + 4px);
    padding:var(--gap); user-select:none; touch-action:none; overflow:hidden;
  }
  /* –°–ª–æ–∏ —Å–µ—Ç–∫–∏ –∏ —Ç–∞–π–ª–æ–≤ —Å–æ–≤–ø–∞–¥–∞—é—Ç –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏: –∞–±—Å–æ–ª—é—Ç –∏ inset —Ä–∞–≤–µ–Ω padding */
  .grid,.tiles{ position:absolute; inset:var(--gap); }
  .grid{
    display:grid;
    grid-template-columns:repeat(var(--size),1fr);
    grid-auto-rows:1fr;
    gap:var(--gap);
    width:100%; height:100%;
  }
  .cell{ background:var(--cell-bg); border-radius:var(--radius); }

  .tiles{ pointer-events:none; }

  /* –¢–∞–π–ª—ã ‚Äî —Å—Ç–∞–≤–∏–º —Ç–æ—á–Ω–æ –ø–æ –ø–∏–∫—Å–µ–ª—å–Ω—ã–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º —è—á–µ–µ–∫, –∞–Ω–∏–º–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ transform */
  .tile{
    position:absolute; border-radius:var(--radius);
    display:grid; place-items:center;
    font-weight:900; line-height:1;
    width:var(--w,0px); height:var(--h,0px);
    transform:translate3d(var(--tx,0), var(--ty,0), 0) scale(var(--s,1));
    transition:transform var(--anim) var(--ease);
    backface-visibility:hidden; will-change:transform;
  }
  .tile.bump{ animation:bump var(--anim) ease-out; }
  @keyframes bump{
    0%{   transform:translate3d(var(--tx), var(--ty), 0) scale(1); }
    50%{  transform:translate3d(var(--tx), var(--ty), 0) scale(1.11); }
    100%{ transform:translate3d(var(--tx), var(--ty), 0) scale(1); }
  }

  .overlay{
    position:absolute; inset:0; display:none; place-items:center;
    background:rgba(0,0,0,.35); border-radius:calc(var(--radius) + 4px);
  }
  .overlay.show{ display:grid; }
  .panel{
    background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.15);
    padding:14px 16px; border-radius:12px; text-align:center; font-weight:800; min-width:60%;
  }
  .panel .title{ font-size:20px; margin-bottom:6px; }
  .panel .row{ margin-top:8px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">2048</div>
      <div class="scores">
        <div class="badge">Score<b id="score">0</b></div>
        <div class="badge">Best<b id="best">0</b></div>
      </div>
    </div>

    <div class="controls">
      <button id="newGame">New Game</button>
      <button id="undo">Undo</button>
      <label>Size:
        <select id="sizeSel">
          <option>3</option>
          <option selected>4</option>
          <option>5</option>
          <option>6</option>
        </select>
      </label>
    </div>

    <div class="hint">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üê ‚Üë ‚Üí ‚Üì –∏–ª–∏ WASD. –ù–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ ‚Äî —Å–≤–∞–π–ø—ã. –ü–æ–±–µ–¥–∞ –Ω–∞ 2048 (–º–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å).</div>

    <div class="board" id="board" style="--size:4">
      <div class="grid" id="grid"></div>
      <div class="tiles" id="tiles"></div>

      <div class="overlay" id="winOv">
        <div class="panel">
          <div class="title">üéâ 2048!</div>
          <div>–•–æ—á–µ—à—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–≥—Ä—É?</div>
          <div class="row">
            <button id="continue">Continue</button>
            <button id="newFromWin">New Game</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="loseOv">
        <div class="panel">
          <div class="title">üí• –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</div>
          <div class="row">
            <button id="restart">Try Again</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // DOM
  const boardEl = document.getElementById('board');
  const gridEl  = document.getElementById('grid');
  const tilesEl = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const sizeSel = document.getElementById('sizeSel');
  const btnNew  = document.getElementById('newGame');
  const btnUndo = document.getElementById('undo');
  const winOv   = document.getElementById('winOv');
  const loseOv  = document.getElementById('loseOv');
  const btnContinue  = document.getElementById('continue');
  const btnNewFromWin= document.getElementById('newFromWin');
  const btnRestart   = document.getElementById('restart');

  // State
  let size = parseInt(localStorage.getItem('2048-size') || '4', 10);
  sizeSel.value = String(size);
  boardEl.style.setProperty('--size', size);

  let tiles = []; // {id,x,y,value, merged, scale}
  let idSeq = 1;
  let score = 0;
  let best  = parseInt(localStorage.getItem('2048-best') || '0', 10);
  bestEl.textContent = best;

  let keepPlaying = false, won = false, over = false, moveLock = false;
  let undoState = null;

  // –ü–æ–ª—É—á–∞–µ–º —Ç–æ—á–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ —Ä–∞–∑–º–µ—Ä—ã —è—á–µ–π–∫–∏ (x,y) –∏–∑ DOM,
  // —á—Ç–æ–±—ã –∏—Å–∫–ª—é—á–∏—Ç—å –ª—é–±—ã–µ –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç–∏ –∏ –æ–±—Ä–µ–∑–∞–Ω–∏—è —Å–ø—Ä–∞–≤–∞/—Å–Ω–∏–∑—É.
  function cellRect(x, y) {
    const idx = y * size + x;
    const cell = gridEl.children[idx];
    const cr = cell.getBoundingClientRect();
    const tr = tilesEl.getBoundingClientRect();
    return {
      tx: cr.left - tr.left,
      ty: cr.top  - tr.top,
      w:  cr.width,
      h:  cr.height
    };
  }

  function styleTile(t, spawn=false, bump=false) {
    const el = tilesEl.querySelector(`.tile[data-id="${t.id}"]`);
    if (!el) return;

    const r = cellRect(t.x, t.y);
    el.style.setProperty('--tx', r.tx + 'px');
    el.style.setProperty('--ty', r.ty + 'px');
    el.style.setProperty('--w',  r.w  + 'px');
    el.style.setProperty('--h',  r.h  + 'px');
    el.style.setProperty('--s',  spawn ? (t.scale ?? 1) : 1);

    if (t._needsText) {
      el.textContent = t.value;
      const { bg, color } = valueStyle(t.value);
      el.style.background = bg;
      el.style.color = color;
      const base = Math.min(r.w, r.h);
      el.style.fontSize = (fontSizeK(t.value) * base) + 'px';
      t._needsText = false;
    }

    if (bump) {
      el.style.animation = 'none';
      requestAnimationFrame(() => {
        el.style.animation = '';
        el.classList.add('bump');
        const clear = () => { el.classList.remove('bump'); el.removeEventListener('animationend', clear); };
        el.addEventListener('animationend', clear);
      });
    }
  }

  function layoutTiles() {
    for (const t of tiles) styleTile(t, false, false);
  }

  // –°–æ–∑–¥–∞–Ω–∏–µ DOM-—ç–ª–µ–º–µ–Ω—Ç–∞ —Ç–∞–π–ª–∞
  function createTileEl(t) {
    const el = document.createElement('div');
    el.className = 'tile';
    el.dataset.id = t.id;
    tilesEl.appendChild(el);
    styleTile(t, true);
  }
  function removeTileEl(t) {
    const el = tilesEl.querySelector(`.tile[data-id="${t.id}"]`);
    if (el && el.parentNode) el.parentNode.removeChild(el);
  }

  // –°–µ—Ç–∫–∞
  function setupGridCells() {
    gridEl.innerHTML = '';
    for (let i=0;i<size*size;i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      gridEl.appendChild(cell);
    }
  }

  // –£—Ç–∏–ª–∏—Ç—ã
  const inBounds = (x,y) => x>=0 && x<size && y>=0 && y<size;
  const VECTORS = { left:{x:-1,y:0}, right:{x:1,y:0}, up:{x:0,y:-1}, down:{x:0,y:1} };
  const valueStyle = (v) => {
    const bg = {
      2:'#eee4da', 4:'#ede0c8', 8:'#f2b179', 16:'#f59563', 32:'#f67c5f', 64:'#f65e3b',
      128:'#edcf72', 256:'#edcc61', 512:'#edc850', 1024:'#edc53f', 2048:'#edc22e'
    }[v] || '#3c3a32';
    const color = v <= 4 ? '#776e65' : '#f9f6f2';
    return { bg, color };
  };
  const fontSizeK = (v) => v < 100 ? .42 : v < 1000 ? .38 : v < 10000 ? .33 : .30;

  function getGrid() {
    const g = Array.from({length:size}, () => Array(size).fill(null));
    for (const t of tiles) g[t.x][t.y] = t;
    return g;
  }
  function emptyCells() {
    const g = getGrid(); const arr = [];
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) if (!g[x][y]) arr.push({x,y});
    return arr;
  }

  // –°—á—ë—Ç
  function setScore(val) {
    score = val; scoreEl.textContent = score;
    if (score > best) {
      best = score; bestEl.textContent = best;
      try { localStorage.setItem('2048-best', String(best)); } catch {}
    }
  }
  function addScore(delta) { setScore(score + delta); }

  // –°–ø–∞–≤–Ω
  function spawnRandom(spawn=false) {
    const empties = emptyCells();
    if (!empties.length) return false;
    const {x,y} = empties[Math.floor(Math.random()*empties.length)];
    const val = Math.random() < 0.9 ? 2 : 4;
    const t = { id: idSeq++, x, y, value: val, scale: spawn ? 0.1 : 1, _needsText: true };
    tiles.push(t);
    createTileEl(t);
    if (spawn) requestAnimationFrame(() => {
      t.scale = 1;
      styleTile(t, true, false);
    });
    return true;
  }

  // –î–≤–∏–∂–µ–Ω–∏–µ
  const ANIM_MS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--anim')) || 0;

  function buildTraversals(vec) {
    const xs = [...Array(size).keys()];
    const ys = [...Array(size).keys()];
    if (vec.x === 1) xs.reverse();
    if (vec.y === 1) ys.reverse();
    return { xs, ys };
  }
  function findFarthest(cell, vec, grid) {
    let prev, x = cell.x, y = cell.y;
    do { prev = {x,y}; x += vec.x; y += vec.y; } while (inBounds(x,y) && !grid[x][y]);
    return { farthest: prev, next: {x, y} };
  }
  function canMoveAny() {
    const g = getGrid();
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) if (!g[x][y]) return true;
    for (let y=0;y<size;y++) for (let x=0;x<size;x++) {
      const t = g[x][y]; if (!t) continue;
      for (const v of Object.values(VECTORS)) {
        const nx = x+v.x, ny = y+v.y; if (!inBounds(nx,ny)) continue;
        const n = g[nx][ny]; if (n && n.value === t.value) return true;
      }
    }
    return false;
  }

  function move(dir) {
    if (over || moveLock) return;
    moveLock = true;

    const vec = VECTORS[dir];
    const { xs, ys } = buildTraversals(vec);
    const grid = getGrid();
    let moved = false, gained = 0;
    const toRemove = new Set(), toBump = [];

    for (const t of tiles) t.merged = false;

    for (const y of ys) for (const x of xs) {
      const t = grid[x][y];
      if (!t) continue;

      const { farthest, next } = findFarthest({x,y}, vec, grid);
      const n = inBounds(next.x,next.y) ? grid[next.x][next.y] : null;

      if (n && n.value === t.value && !n.merged) {
        grid[t.x][t.y] = null;
        t.x = next.x; t.y = next.y;
        t.value *= 2; t.merged = true; t._needsText = true;
        grid[next.x][next.y] = t;

        toRemove.add(n);
        moved = true; gained += t.value; toBump.push(t);
      } else {
        if (farthest.x !== t.x || farthest.y !== t.y) {
          grid[t.x][t.y] = null;
          t.x = farthest.x; t.y = farthest.y;
          grid[t.x][t.y] = t;
          moved = true;
        }
      }
    }

    if (!moved) { moveLock = false; return; }

    if (toRemove.size) {
      tiles = tiles.filter(t => !toRemove.has(t));
      for (const r of toRemove) removeTileEl(r);
    }

    requestAnimationFrame(() => {
      for (const t of tiles) styleTile(t, false, false);
      for (const t of toBump) styleTile(t, false, true);
    });

    setTimeout(() => {
      if (gained) addScore(gained);
      if (tiles.some(t => t.value === 2048) && !keepPlaying) {
        won = true; winOv.classList.add('show');
      } else {
        spawnRandom(true);
        saveUndo();
        if (!canMoveAny()) { over = true; loseOv.classList.add('show'); }
      }
      moveLock = false;
    }, ANIM_MS);
  }

  // Undo
  function saveUndo() {
    undoState = { tiles: tiles.map(t => ({...t})), score, won, keepPlaying, over };
  }
  function undo() {
    if (!undoState || moveLock) return;
    tiles = undoState.tiles.map(t => ({...t}));
    score = undoState.score; scoreEl.textContent = score;
    won = undoState.won; keepPlaying = undoState.keepPlaying; over = undoState.over;
    tilesEl.innerHTML = '';
    for (const t of tiles) { t._needsText = true; createTileEl(t); }
    // –ø–æ—Å–ª–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑–º–µ—Ä—è–µ–º –∏ —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ–º
    requestAnimationFrame(() => requestAnimationFrame(layoutTiles));
    winOv.classList.toggle('show', won && !keepPlaying);
    loseOv.classList.toggle('show', over);
  }

  // Input
  document.addEventListener('keydown', (e) => {
    const c = e.code;
    if (winOv.classList.contains('show') || loseOv.classList.contains('show')) {
      if (c === 'Enter' || c === 'Space') {
        if (winOv.classList.contains('show')) { keepPlaying = true; winOv.classList.remove('show'); }
        else restart();
      }
      return;
    }
    if (c === 'ArrowLeft' || c === 'KeyA') { e.preventDefault(); move('left'); }
    if (c === 'ArrowRight'|| c === 'KeyD') { e.preventDefault(); move('right'); }
    if (c === 'ArrowUp'   || c === 'KeyW') { e.preventDefault(); move('up'); }
    if (c === 'ArrowDown' || c === 'KeyS') { e.preventDefault(); move('down'); }
    if (c === 'KeyU') { e.preventDefault(); undo(); }
    if (c === 'KeyN' || c === 'KeyR') { e.preventDefault(); restart(); }
  }, { passive: false });

  // Touch swipes
  let sx=0, sy=0, st=0;
  boardEl.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0]; sx=t.clientX; sy=t.clientY; st=performance.now();
  }, {passive:true});
  boardEl.addEventListener('touchend', (e) => {
    const t = e.changedTouches[0];
    const dx=t.clientX-sx, dy=t.clientY-sy, dt=performance.now()-st;
    const thr=24; if (dt>800) return;
    if (Math.abs(dx)<thr && Math.abs(dy)<thr) return;
    if (Math.abs(dx)>Math.abs(dy)) move(dx>0?'right':'left'); else move(dy>0?'down':'up');
  }, {passive:true});

  // Buttons
  function restart(){
    winOv.classList.remove('show'); loseOv.classList.remove('show');
    keepPlaying=false; won=false; over=false;
    reset();
  }
  btnNew.addEventListener('click', restart);
  btnUndo.addEventListener('click', undo);
  sizeSel.addEventListener('change', () => {
    size = parseInt(sizeSel.value, 10);
    try { localStorage.setItem('2048-size', String(size)); } catch {}
    boardEl.style.setProperty('--size', size);
    restart();
  });
  btnContinue.addEventListener('click', () => { keepPlaying = true; winOv.classList.remove('show'); });
  btnNewFromWin.addEventListener('click', restart);
  btnRestart.addEventListener('click', restart);

  // Game boot
  function reset() {
    tiles = []; idSeq = 1; setScore(0);
    tilesEl.innerHTML = ''; setupGridCells();
    // –ñ–¥—ë–º —Ä–∞—Å–∫–ª–∞–¥–∫–∏, –ø–æ—Ç–æ–º —Å–ø–∞–≤–Ω–∏–º –∏ —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ–º —Ç–∞–π–ª—ã –ø–æ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º —è—á–µ–µ–∫.
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        spawnRandom(true); spawnRandom(true); saveUndo(); layoutTiles();
      });
    });
  }
  function boot(){
    setupGridCells();
    requestAnimationFrame(() => requestAnimationFrame(reset));
    // –ü–µ—Ä–µ—Ä–∞—Å–∫–ª–∞–¥–∫–∞ –ø—Ä–∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏/—Ä–µ—Å–∞–π–∑–µ ‚Äî –ø–µ—Ä–µ—Å—á—ë—Ç –ø–æ–∑–∏—Ü–∏–π –ø–æ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–º rect —è—á–µ–µ–∫
    const ro = new ResizeObserver(() => { requestAnimationFrame(() => requestAnimationFrame(layoutTiles)); });
    ro.observe(gridEl);
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>
</body>
</html>
