<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <title>Bewords Match‑3 — Мобильная адаптация (свайпы + звуки)</title>
  <style>
    :root{
      --gap: 6px;
      --bg: #111418;
      --panel: #1b2128;
      --text: #eaf1f8;
      --muted: #b8c2cc;
      --accent: #66d1ff;
    }
    * { box-sizing: border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(1200px 600px at 80% -20%, #1b1f2a 0, transparent 60%),
        radial-gradient(1000px 700px at -10% 100%, #0b0f14 0, transparent 60%),
        var(--bg);
      color:var(--text);
      font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: contain;
      overflow-x: hidden; /* важно — чтобы не было горизонтального скролла */
    }
    .wrap{
      width:100vw;
      max-width:760px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      align-items:start;
      padding:
        calc(16px + env(safe-area-inset-top, 0px))
        calc(16px + env(safe-area-inset-right, 0px))
        calc(16px + env(safe-area-inset-bottom, 0px))
        calc(16px + env(safe-area-inset-left, 0px));
      margin:0 auto;
    }
    h1{
      margin:0;
      font-weight:800;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:20px;
    }
    h1 .dot{ width:10px; height:10px; border-radius:50%; background: var(--accent); display:inline-block; box-shadow:0 0 12px #66d1ff80; }

    .hud{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      background:var(--panel);
      padding:10px; border-radius:12px; border:1px solid #ffffff10;
      box-shadow: 0 6px 20px #00000050, inset 0 1px 0 #ffffff10;
      width:100%;
    }
    .hud .card{
      background:#0f141a;
      padding:8px 12px; border-radius:10px; border:1px solid #ffffff0f;
      min-width:96px; text-align:center;
    }
    .hud .big{ font-size:18px; font-weight:800; }
    .hud .label{ font-size:12px; color:var(--muted); letter-spacing:.2px; }
    .btn{
      appearance:none; border:0; background:linear-gradient(180deg, #2e7df7, #1857df);
      color:#fff; font-weight:700; padding:10px 14px; border-radius:10px;
      box-shadow:0 6px 16px #1653d060, inset 0 1px 0 #ffffff66; cursor:pointer;
      transition:.15s transform ease, .15s filter ease;
      touch-action: manipulation;
    }
    .btn.secondary{
      background:#334155;
      box-shadow: inset 0 1px 0 #ffffff30;
    }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .hint{
      color:var(--muted); margin:0;
    }

    /* АДАПТАЦИЯ: доска теперь 100% ширины, колонки — 1fr, клетки квадратные через aspect-ratio */
    .board{
      width:100%;
      background:#0b0e12;
      padding:var(--gap);
      border-radius:14px; border:1px solid #ffffff10;
      box-shadow: 0 10px 30px #00000070, inset 0 2px 0 #ffffff08, inset 0 -2px 0 #00000070;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      gap: var(--gap);
      touch-action: none; /* отключаем прокрутку жестами на поле */
      position:relative;
      user-select:none;
    }
    .board.shake{ animation:shake .18s ease; }
    @keyframes shake {
      0%{ transform: translateX(0) }
      25%{ transform: translateX(-4px) }
      50%{ transform: translateX(4px) }
      75%{ transform: translateX(-2px) }
      100%{ transform: translateX(0) }
    }

    .cell{
      width:100%;
      aspect-ratio: 1 / 1; /* квадрат — автоматически под ширину колонки */
      border-radius:14px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid #00000040;
      background:#0f141a;
      box-shadow: inset 0 -8px 0 #00000030, inset 0 1px 0 #ffffff20;
      position:relative;
      overflow:hidden;
      touch-action:none;
    }
    .cell.selected{
      outline:3px solid #ffffffcc;
      filter: brightness(1.1) saturate(1.15);
      z-index:2;
    }
    .cell.empty{ visibility:hidden; }

    .candy{
      width:84%;
      height:84%;
      border-radius:50%;
      box-shadow:
        inset 0 -10px 16px #00000035,
        inset 0 -2px 2px #00000050,
        0 4px 10px #00000050;
      position:relative;
      transition: transform .12s ease, opacity .12s ease, filter .12s ease;
    }
    .candy::after{
      content:"";
      position:absolute;
      left:8%; top:10%;
      width:50%; height:40%;
      border-radius:50%;
      background: linear-gradient(180deg, #ffffffcc, transparent 70%);
      filter: blur(2px);
      opacity:.8;
      transform: rotate(-20deg);
      pointer-events:none;
    }

    /* 6 типов конфет */
    .type-0 .candy{
      background:
        repeating-linear-gradient(45deg, #ff9c9c 0 10px, #ff7f7f 10px 20px),
        radial-gradient(circle at 30% 30%, #ffb9b9, #ff4141);
    }
    .type-1 .candy{
      background:
        repeating-linear-gradient(45deg, #ffd49c 0 10px, #ffbf6b 10px 20px),
        radial-gradient(circle at 30% 30%, #ffdcae, #ff9933);
    }
    .type-2 .candy{
      background:
        repeating-linear-gradient(45deg, #fff19c 0 10px, #ffe36b 10px 20px),
        radial-gradient(circle at 30% 30%, #fff3b0, #ffcf33);
    }
    .type-3 .candy{
      background:
        repeating-linear-gradient(45deg, #a5f5b0 0 10px, #76e592 10px 20px),
        radial-gradient(circle at 30% 30%, #c7fbd0, #23c766);
    }
    .type-4 .candy{
      background:
        repeating-linear-gradient(45deg, #a4c7ff 0 10px, #7dadff 10px 20px),
        radial-gradient(circle at 30% 30%, #c1d6ff, #3f7bff);
    }
    .type-5 .candy{
      background:
        repeating-linear-gradient(45deg, #d9a8ff 0 10px, #c384ff 10px 20px),
        radial-gradient(circle at 30% 30%, #eac8ff, #8f3fff);
    }

    .crush{ animation: crush .24s ease forwards; }
    .new{ animation: popIn .18s ease; }
    @keyframes crush{
      50%{ transform: scale(0.7); filter: brightness(1.3); }
      100%{ transform: scale(0); opacity:0; }
    }
    @keyframes popIn{
      from{ transform: scale(.6); opacity:.6; }
      to{ transform: scale(1); opacity:1; }
    }

    /* Floating labels (очки/надписи) */
    .float{
      position:absolute;
      left:0; top:0;
      transform: translate(-50%, -50%);
      padding:4px 8px; border-radius:8px;
      background:#00000080; color:#fff; font-weight:800; pointer-events:none;
      border:1px solid #ffffff30;
      animation: floatUp .9s ease forwards;
      z-index:5;
      font-size:14px;
    }
    @keyframes floatUp{
      from{ opacity:1; transform: translate(-50%, -50%) translateY(0); }
      to{ opacity:0; transform: translate(-50%, -50%) translateY(-24px); }
    }

    .overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:#00000080; backdrop-filter: blur(2px);
      opacity:0; pointer-events:none; transition:.2s opacity ease;
      z-index:10;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }
    .modal{
      background:var(--panel); border:1px solid #ffffff1a; border-radius:14px;
      padding:20px; width:min(92vw, 380px); text-align:center;
      box-shadow: 0 20px 40px #00000080, inset 0 1px 0 #ffffff10;
    }
    .modal h2{ margin:0 0 6px 0; }
    .modal p{ margin:4px 0 16px 0; color:#cbd5e1; }

    /* На очень узких экранах уменьшаем шрифты/отступы */
    @media (max-width: 380px){
      h1{ font-size:18px; }
      .hud .big{ font-size:16px; }
      .btn{ padding:9px 12px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>
      <span class="dot"></span>
      Bewords game : match-3
    </h1>

    <div class="hud">
      <div class="card">
        <div class="label">Счет</div>
        <div class="big" id="score">0</div>
      </div>
      <div class="card">
        <div class="label">Ходы</div>
        <div class="big" id="moves">30</div>
      </div>
      <div class="card">
        <div class="label">Рекорд</div>
        <div class="big" id="best">0</div>
      </div>
      <button class="btn" id="restart">Перезапуск</button>
      <button class="btn secondary" id="toggleSound">Звук/Haptic: Вкл</button>
    </div>
    <p class="hint">Свайпни по фишке к соседней (вверх/вниз/влево/вправо), чтобы поменять местами. Клик по соседней тоже работает.</p>

    <div class="board" id="board" aria-label="Игровое поле" role="grid"></div>
  </div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <h2>Игра окончена!</h2>
      <p>Ваш счет: <b id="finalScore">0</b></p>
      <button class="btn" id="playAgain">Сыграть еще</button>
    </div>
  </div>

  <script>
    ;(()=> {
      const ROWS = 8;
      const COLS = 8;
      const TYPES = 6;
      const START_MOVES = 30;

      const $board = document.getElementById('board');
      const $score = document.getElementById('score');
      const $moves = document.getElementById('moves');
      const $best  = document.getElementById('best');
      const $restart = document.getElementById('restart');
      const $toggleSound = document.getElementById('toggleSound');
      const $overlay = document.getElementById('overlay');
      const $finalScore = document.getElementById('finalScore');
      const $playAgain = document.getElementById('playAgain');

      let board = [];
      let score = 0;
      let best = 0;
      let movesLeft = START_MOVES;
      let selected = null; // {r,c}
      let busy = false;

      // gestures
      let swipeStart = null; // {r,c,x,y}
      const SWIPE_THRESHOLD = 20; // px

      // settings
      let soundOn = true;

      // Audio SFX на WebAudio (без файлов)
      const audio = {
        ctx: null,
        ensure(){
          if(!this.ctx){
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          }
        },
        tone({freq=440, dur=0.08, type='sine', gain=0.06}={}){
          if(!soundOn) return;
          this.ensure();
          const t0 = this.ctx.currentTime;
          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, t0);
          g.gain.setValueAtTime(0, t0);
          g.gain.linearRampToValueAtTime(gain, t0+0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
          osc.connect(g).connect(this.ctx.destination);
          osc.start(t0);
          osc.stop(t0+dur+0.02);
        },
        chord(freqs=[440,660], dur=0.12){
          freqs.forEach((f,i)=> this.tone({freq:f, dur:dur-0.02*i, type:'sine', gain:0.05}));
        },
        error(){
          this.tone({freq:180, dur:0.11, type:'square', gain:0.05});
          setTimeout(()=> this.tone({freq:160, dur:0.11, type:'square', gain:0.05}), 60);
        },
        swap(){ this.tone({freq:360, dur:0.07, type:'triangle'}); },
        match(){ this.chord([660,880], 0.14); },
        combo(n=2){ this.chord([520,780,1040], 0.16); for(let i=1;i<n;i++) setTimeout(()=>this.tone({freq:520+120*i, dur:0.08}), 70*i); },
        shuffle(){ this.tone({freq:420, dur:0.06}); setTimeout(()=>this.tone({freq:280, dur:0.08}), 60); },
        click(){ this.tone({freq:520, dur:0.05}); },
      };

      // Utils
      const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));
      const inBounds = (r,c)=> r>=0 && r<ROWS && c>=0 && c<COLS;
      const isNeighbor = (a,b)=> a && b && (Math.abs(a.r-b.r)+Math.abs(a.c-b.c)===1);
      const randType = ()=> Math.floor(Math.random()*TYPES);

      // Save/load best score
      function loadBest(){
        try{
          const v = localStorage.getItem('bewords-best');
          if(v) best = +v || 0;
        }catch{}
      }
      function saveBest(){
        try{ localStorage.setItem('bewords-best', String(best)); }catch{}
      }

      // Board generation
      function newBoardRandom(){
        return Array.from({length:ROWS}, _ => Array.from({length:COLS}, _ => randType()));
      }
      function findMatches(){
        const set = new Set();

        // horizontal
        for(let r=0; r<ROWS; r++){
          let count = 1;
          for(let c=1; c<=COLS; c++){
            const prev = board[r][c-1];
            const curr = c<COLS ? board[r][c] : null;
            if(curr === prev && prev !== -1){
              count++;
            }else{
              if(prev !== -1 && count >= 3){
                for(let k=0; k<count; k++){
                  set.add(`${r},${c-1-k}`);
                }
              }
              count = 1;
            }
          }
        }
        // vertical
        for(let c=0; c<COLS; c++){
          let count = 1;
          for(let r=1; r<=ROWS; r++){
            const prev = board[r-1][c];
            const curr = r<ROWS ? board[r][c] : null;
            if(curr === prev && prev !== -1){
              count++;
            }else{
              if(prev !== -1 && count >= 3){
                for(let k=0; k<count; k++){
                  set.add(`${r-1-k},${c}`);
                }
              }
              count = 1;
            }
          }
        }
        return set;
      }
      function swapInBoard(a, b){
        const t = board[a.r][a.c];
        board[a.r][a.c] = board[b.r][b.c];
        board[b.r][b.c] = t;
      }
      function hasAvailableMoves(){
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            const here = {r,c};
            const right = {r, c:c+1};
            if(inBounds(right.r,right.c)){
              swapInBoard(here, right);
              const any = findMatches().size>0;
              swapInBoard(here, right);
              if(any) return true;
            }
            const down = {r:r+1, c};
            if(inBounds(down.r,down.c)){
              swapInBoard(here, down);
              const any = findMatches().size>0;
              swapInBoard(here, down);
              if(any) return true;
            }
          }
        }
        return false;
      }
      function ensureStartableBoard(){
        let safety = 0;
        do {
          board = newBoardRandom();
          safety++;
          if(safety>500) break;
        } while(findMatches().size>0 || !hasAvailableMoves());
      }

      function collapseAndFill(){
        const newCells = [];
        for(let c=0;c<COLS;c++){
          let write = ROWS - 1;
          for(let r=ROWS-1;r>=0;r--){
            if(board[r][c] !== -1){
              board[write][c] = board[r][c];
              if(write !== r) board[r][c] = -1;
              write--;
            }
          }
          for(let r=write; r>=0; r--){
            board[r][c] = randType();
            newCells.push({r,c});
          }
        }
        return newCells;
      }

      // Rendering
      function renderBoard(){
        $board.innerHTML = "";
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            const wrapper = document.createElement('div');
            wrapper.className = 'cell';
            wrapper.setAttribute('role','gridcell');
            wrapper.dataset.row = r;
            wrapper.dataset.col = c;

            const val = board[r][c];
            if(val === -1){
              wrapper.classList.add('empty');
            } else {
              wrapper.classList.add(`type-${val}`);
              const candy = document.createElement('div');
              candy.className = 'candy';
              wrapper.appendChild(candy);
            }

            if(selected && selected.r===r && selected.c===c){
              wrapper.classList.add('selected');
            }

            wrapper.addEventListener('pointerdown', onPointerDown, {passive:false});
            wrapper.addEventListener('pointermove', onPointerMove, {passive:false});
            wrapper.addEventListener('pointerup', onPointerUp, {passive:false});
            wrapper.addEventListener('click', onCellClick, {passive:true});
            $board.appendChild(wrapper);
          }
        }
        updateHud();
      }
      function queryCell(r,c){
        return $board.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      }

      function addCrushAnimation(matchSet){
        for(const key of matchSet){
          const [r,c] = key.split(',').map(Number);
          const el = queryCell(r,c);
          if(el) el.classList.add('crush');
        }
      }
      function addNewAnimation(cells){
        for(const {r,c} of cells){
          const el = queryCell(r,c);
          if(!el) continue;
          el.classList.add('new');
        }
      }

      // Floating labels — вычисляем координаты из реальной ширины доски
      function floatLabel(text, cells){
        if(!cells || cells.length===0) return;

        const avg = cells.reduce((a,p)=>({x:a.x+p.c,y:a.y+p.r}),{x:0,y:0});
        const cx = avg.x / cells.length;
        const cy = avg.y / cells.length;

        const boardRect = $board.getBoundingClientRect();
        const cs = getComputedStyle($board);
        const gap = parseFloat(cs.gap) || 6;
        const padL = parseFloat(cs.paddingLeft) || 0;
        const padT = parseFloat(cs.paddingTop) || 0;

        // реальная ширина сетки внутри padding
        const innerW = boardRect.width - padL - (parseFloat(cs.paddingRight) || 0);
        const cellSize = (innerW - gap*(COLS-1)) / COLS;

        const x = boardRect.left + window.scrollX + padL + cx*(cellSize+gap) + cellSize/2;
        const y = boardRect.top  + window.scrollY + padT + cy*(cellSize+gap) + cellSize/2;

        const span = document.createElement('span');
        span.className = 'float';
        span.style.left = `${x}px`;
        span.style.top  = `${y}px`;
        span.textContent = text;
        document.body.appendChild(span);
        setTimeout(()=> span.remove(), 900);
      }

      // HUD
      function updateHud(){
        $score.textContent = String(score);
        $moves.textContent = String(movesLeft);
        $best.textContent = String(best);
      }

      // Game flow
      async function resolveCascade(){
        let chain = 0;
        while(true){
          const matches = findMatches();
          if(matches.size === 0) break;

          chain++;
          const list = Array.from(matches).map(k => {
            const [r,c] = k.split(',').map(Number);
            return {r,c};
          });

          const points = matches.size * 10 * chain;
          score += points;
          if(score > best){ best = score; saveBest(); }
          addCrushAnimation(matches);
          updateHud();

          // звуки / эффекты
          vibrate(10);
          audio.match();
          if(matches.size >= 4){
            floatLabel('Молодец!', list);
            audio.tone({freq:900, dur:0.08});
          }
          if(chain >= 2){
            floatLabel(`Комбо x${chain}!`, list);
            audio.combo(Math.min(chain, 4));
          }
          floatLabel(`+${points}`, list);

          await sleep(240);
          // очистка
          for(const key of matches){
            const [r,c] = key.split(',').map(Number);
            board[r][c] = -1;
          }
          const newCells = collapseAndFill();
          renderBoard();
          addNewAnimation(newCells);
          await sleep(120);
        }
      }

      async function trySwap(a,b){
        if(busy) return;
        busy = true;
        swapInBoard(a,b);
        renderBoard();
        audio.swap();

        await sleep(110);

        const matches = findMatches();
        if(matches.size > 0){
          movesLeft = Math.max(0, movesLeft - 1);
          updateHud();
          await resolveCascade();
          if(movesLeft <= 0){
            endGame();
          } else if(!hasAvailableMoves()){
            await shuffleBoardAnimated();
          }
        } else {
          swapInBoard(a,b);
          renderBoard();
          $board.classList.add('shake');
          setTimeout(()=> $board.classList.remove('shake'), 200);
          audio.error();
          vibrate(30);
        }
        selected = null;
        renderBoard();
        busy = false;
      }

      async function shuffleBoardAnimated(){
        let tries = 0;
        do {
          const pool = [];
          for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) pool.push(board[r][c]);
          for(let i=pool.length-1;i>0;i--){
            const j = Math.floor(Math.random()*(i+1));
            [pool[i], pool[j]] = [pool[j], pool[i]];
          }
          let idx = 0;
          for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) board[r][c] = pool[idx++];
          tries++;
          if(tries>200){
            ensureStartableBoard();
            break;
          }
        } while(findMatches().size>0 || !hasAvailableMoves());
        renderBoard();
        const all = [];
        for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) all.push({r,c});
        addNewAnimation(all);
        audio.shuffle();
        await sleep(160);
      }

      function endGame(){
        busy = true;
        $finalScore.textContent = String(score);
        $overlay.classList.add('show');
      }
      function resetGame(){
        score = 0;
        movesLeft = START_MOVES;
        selected = null;
        busy = false;
        ensureStartableBoard();
        renderBoard();
      }

      // Gestures
      function getRCFromTarget(t){
        if(!t) return null;
        const r = +t.dataset.row;
        const c = +t.dataset.col;
        if(Number.isFinite(r) && Number.isFinite(c)) return {r,c};
        return null;
      }
      function onPointerDown(e){
        if(busy) return;
        e.preventDefault();
        const pos = getRCFromTarget(e.currentTarget);
        if(!pos) return;
        swipeStart = { r: pos.r, c: pos.c, x: e.clientX, y: e.clientY };
        selected = pos;
        renderBoard();
        e.currentTarget.setPointerCapture?.(e.pointerId);
      }
      function onPointerMove(e){
        if(busy || !swipeStart) return;
        e.preventDefault();
        const dx = e.clientX - swipeStart.x;
        const dy = e.clientY - swipeStart.y;
        const adx = Math.abs(dx), ady = Math.abs(dy);
        if(Math.max(adx, ady) < SWIPE_THRESHOLD) return;
        let to = null;
        if(adx > ady){
          to = { r: swipeStart.r, c: swipeStart.c + (dx>0?1:-1) };
        } else {
          to = { r: swipeStart.r + (dy>0?1:-1), c: swipeStart.c };
        }
        if(to && inBounds(to.r, to.c)){
          trySwap({r: swipeStart.r, c: swipeStart.c}, to);
          swipeStart = null;
        }
      }
      function onPointerUp(e){
        if(busy) return;
        swipeStart = null;
      }

      // Резерв: «клик по соседней»
      function onCellClick(e){
        if(busy) return;
        const el = e.currentTarget;
        const r = +el.dataset.row;
        const c = +el.dataset.col;
        const pos = {r,c};

        if(!selected){
          selected = pos;
          renderBoard();
          audio.click();
          return;
        }
        if(selected.r === r && selected.c === c){
          selected = null;
          renderBoard();
          return;
        }
        if(isNeighbor(selected, pos)){
          trySwap(selected, pos);
        } else {
          selected = pos;
          renderBoard();
        }
      }

      function vibrate(ms){
        if(!soundOn) return;
        if(navigator.vibrate) navigator.vibrate(ms);
      }

      // Events
      $restart.addEventListener('click', ()=>{ audio.click(); resetGame(); });
      $playAgain.addEventListener('click', ()=> { audio.click(); $overlay.classList.remove('show'); resetGame(); });
      $toggleSound.addEventListener('click', ()=>{
        soundOn = !soundOn;
        $toggleSound.textContent = `Звук/Haptic: ${soundOn ? 'Вкл' : 'Выкл'}`;
        audio.click();
      });

      // Init
      loadBest();
      updateHud();
      resetGame();

      // Ничего не нужно при resize — сетка резиновая 1fr + aspect-ratio
    })();
  </script>
</body>
</html>
